<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>O Monstro Comil√£o - Para Lavine</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #f0f8ff;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            touch-action: none; user-select: none; -webkit-user-select: none;
            width: 100vw; height: 100vh; overscroll-behavior: none;
        }

        #game-container {
            position: relative; width: 100%; height: 100%;
            overflow: hidden; box-sizing: border-box;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* --- O MONSTRO --- */
        #monster-container {
            position: absolute; top: 32%; left: 50%;
            transform: translate(-50%, -50%);
            height: 42vh; width: auto; max-height: 400px; min-height: 250px;
            z-index: 10; transition: all 0.5s ease; 
            pointer-events: none; 
        }
        
        .interactive {
            pointer-events: auto !important;
            cursor: pointer;
        }

        #monster-svg { width: 100%; height: 100%; display: block; }
        
        /* Sujeira */
        .dirt-spot {
            fill: #795548; /* Marrom suave */
            opacity: 0.6;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform-origin: center;
        }

        .monster-idle { animation: breathe 3s infinite ease-in-out; }
        @keyframes breathe { 
            0%, 100% { transform: translate(-50%, -50%) scale(1); } 
            50% { transform: translate(-50%, -50%) scale(1.03); } 
        }

        #mouth-sensor {
            position: absolute; top: 35%; left: 20%; width: 60%; height: 35%; 
            z-index: 15; pointer-events: auto;
        }

        /* --- BARRIGA --- */
        #belly-container {
            position: absolute; top: 71.4%; left: 50%; 
            transform: translate(-50%, -50%);
            width: 35%; height: 25%;
            display: flex; justify-content: center; align-items: center; z-index: 12;
            pointer-events: none;
        }

        #belly-counter {
            font-size: clamp(2.5rem, 6vh, 4.5rem);
            font-weight: bold; color: #fff; text-shadow: 3px 3px 0 #000;
            z-index: 14; position: absolute; margin: 0; padding: 0;
            line-height: 1;
        }

        #eaten-fruits-visuals {
            position: absolute; width: 100%; height: 100%;
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center;
            opacity: 0.5; z-index: 13;
        }

        .eaten-fruit {
            width: 25% !important; height: 25% !important; margin: 2px;
            position: relative !important; transform: none !important;
        }

        /* --- ESTADOS VISUAIS DO MONSTRO --- */
        .sick-face #monster-body { fill: #a8d5ba !important; transition: fill 0.5s; }
        .sick-face .eye-pupil { transform: scale(0.5); }
        .sick-face .mouth-path { d: path("M75 150 Q110 140 150 150 Q190 160 225 150"); fill: none; stroke: #333; stroke-width: 5; }
        .sick-face .teeth { display: none; }
        
        .mouth-open .mouth-path { d: path("M75 130 Q150 130 225 130 Q225 210 150 210 Q75 210 75 130 Z") !important; }
        .mouth-open .teeth { display: none; }

        .heart-face .mouth-path { d: path("M100 160 Q150 190 200 160"); fill: none; stroke: #ff4757; stroke-width: 6; stroke-linecap: round; }
        .heart-face .eye-pupil { display: none; }
        .heart-face .eye-lid { d: path("M85 100 Q100 85 115 100 M185 100 Q200 85 215 100"); fill: none; stroke: #333; stroke-width: 4; }
        #blush-group { display: none; opacity: 0.6; }
        .heart-face #blush-group { display: block; }

        /* --- PRATELEIRA --- */
        #fruit-shelf {
            position: absolute; bottom: calc(18% + env(safe-area-inset-bottom)); 
            left: 50%; transform: translateX(-50%);
            width: 94%; max-width: 600px; height: 90px;
            background: #deb887; border-radius: 20px;
            border-bottom: 8px solid #cda56f; box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            display: flex; justify-content: space-around; align-items: center;
            z-index: 50; padding: 0 10px;
        }

        .shelf-support { position: absolute; top: 100%; width: 18px; height: 100vh; background: #cda56f; z-index: 40; }
        .support-left { left: 40px; }
        .support-right { right: 40px; }

        .basket-item {
            width: 75px; height: 75px; position: relative; cursor: grab;
            transition: transform 0.1s; margin-bottom: 35px; 
            filter: drop-shadow(0 5px 5px rgba(0,0,0,0.2)); z-index: 55; touch-action: none;
        }

        .fruit-drag {
            width: 95px; height: 95px; position: absolute; z-index: 1000;
            pointer-events: none; filter: drop-shadow(15px 15px 20px rgba(0,0,0,0.3));
        }

        /* --- LIQUIDIFICADOR --- */
        #blender-wrapper {
            position: absolute; top: 140px; right: 15px;
            width: 110px; height: 160px; z-index: 60;
            display: none; touch-action: none; transform-origin: center center; 
        }
        #blender-container { width: 100%; height: 100%; transform-origin: center bottom; position: relative; }
        #blender-items-visuals {
            position: absolute; top: 50px; left: 30px; width: 50px; height: 80px;
            display: flex; flex-wrap: wrap; justify-content: center; align-content: flex-end;
            z-index: 2; pointer-events: none;
        }
        .blender-fruit-tiny { width: 25px; height: 25px; margin: 1px; }
        .blender-ready { cursor: grab; animation: shake 0.3s infinite; filter: drop-shadow(0 0 15px gold); }
        #blender-sensor { position: absolute; top: -20px; left: -20px; width: 140%; height: 140%; z-index: 10; }

        /* --- SPONGE (BANHO) --- */
        #sponge-cursor {
            position: fixed; width: 60px; height: 60px;
            background: #f1c40f; border-radius: 10px;
            border: 3px solid #e67e22;
            pointer-events: none; z-index: 9999; display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        #sponge-cursor::after {
            content: ".:"; color: #d35400; font-size: 20px; font-weight: bold;
            position: absolute; top: 5px; left: 10px;
        }
        #sponge-cursor::before {
            content: "o"; color: #d35400; font-size: 15px;
            position: absolute; bottom: 10px; right: 10px;
        }

        /* --- PARTICULAS --- */
        .heart-particle {
            position: absolute; pointer-events: none; z-index: 100;
            animation: floatUp 1.5s forwards ease-out; font-size: 30px;
        }
        .bubble-particle {
            position: absolute; pointer-events: none; z-index: 100;
            width: 20px; height: 20px; background: rgba(255,255,255,0.6);
            border: 1px solid white; border-radius: 50%;
            animation: floatUp 2s forwards ease-in;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 1; }
            100% { transform: translateY(-200px) scale(1.5); opacity: 0; }
        }

        /* --- UI E BOT√ïES --- */
        #controls-sidebar {
            position: absolute; left: 15px; top: calc(100px + env(safe-area-inset-top));
            display: flex; flex-direction: column; gap: 15px; z-index: 60;
        }
        .control-btn {
            width: 65px; height: 65px; background: white; border-radius: 20px;
            border: 4px solid #3498db; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 6px 0 #2980b9; transition: all 0.1s; cursor: pointer;
            pointer-events: auto;
        }
        .control-btn:active { transform: translateY(3px); box-shadow: 0 3px 0 #2980b9; }

        .btn-active {
            background: #ffeaa7 !important; border-color: #f1c40f !important;
            box-shadow: 0 6px 0 #f39c12 !important; animation: pulse-active 1.5s infinite;
        }
        @keyframes pulse-active { 
            0%, 100% { transform: scale(1); } 
            50% { transform: scale(1.08); } 
        }

        #poop-btn {
            position: absolute; top: 50%; right: 20px; transform: translateY(-50%);
            width: 100px; height: 100px; background: #fff; border-radius: 50%;
            border: 6px solid #e74c3c; display: none; justify-content: center; align-items: center;
            z-index: 70; animation: pulse-btn 1.2s infinite; cursor: pointer;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }

        @keyframes dropPoop { 
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 
            15% { opacity: 1; transform: translate(-50%, 60px) scale(1.1); } 
            100% { transform: translate(-50%, 100vh) scale(1); opacity: 1; } 
        }
        .poop-drop { position: absolute; font-size: 85px; z-index: 5; animation: dropPoop 2.2s forwards; left: 50%; }

        #instruction-bubble {
            background: white; padding: 10px 25px; border-radius: 50px; display: inline-block;
            border: 4px solid #333; font-size: 1.4rem; box-shadow: 0 6px 0 rgba(0,0,0,0.15); 
            max-width: 80%;
        }
        #ui-layer { position: absolute; top: calc(10px + env(safe-area-inset-top)); width: 100%; text-align: center; z-index: 20; pointer-events: none; }
        .highlight-num { color: #e74c3c; font-weight: bold; font-size: 1.7rem; }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #2ecc71; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200;
        }
        .big-btn {
            background: #fff; color: #2ecc71; border: none; padding: 25px 80px;
            font-size: 2.5rem; border-radius: 60px; cursor: pointer;
            box-shadow: 0 12px 0 #27ae60; font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color:white; font-size: 3rem; text-shadow: 4px 4px 0 #000; text-align:center;">O Monstro Comil√£o</h1>
        <div style="font-size: 6rem; margin: 20px;">ü¶ñüçé</div>
        <button class="big-btn" onclick="startGame()">JOGAR</button>
        <p style="color:white; margin-top:40px; font-weight:bold; font-size: 1.3rem;">Para a Lavine ‚ù§Ô∏è</p>
    </div>

    <div id="sponge-cursor"></div>

    <div id="controls-sidebar">
        <div id="btn-blender" class="control-btn" onclick="setMode('blender')" title="Modo Vitamina">
            <svg viewBox="0 0 100 100" width="45" height="45">
                <rect x="25" y="75" width="50" height="15" rx="5" fill="#333" />
                <path d="M30 20 L70 20 L65 75 L35 75 Z" fill="#81ecec" stroke="#333" stroke-width="3"/>
                <rect x="28" y="12" width="44" height="8" rx="2" fill="#e74c3c" />
                <circle cx="50" cy="82" r="4" fill="#f1c40f" />
            </svg>
        </div>
        <div id="btn-heart" class="control-btn" onclick="setMode('heart')" title="Modo Carinho">
            <span style="font-size: 35px;">‚ù§Ô∏è</span>
        </div>
        <div id="btn-bath" class="control-btn" onclick="setMode('bath')" title="Modo Banho">
            <svg viewBox="0 0 100 100" width="45" height="45">
                <path d="M20 80 Q20 40 50 40 Q80 40 80 80" fill="none" stroke="#3498db" stroke-width="4" />
                <rect x="30" y="20" width="40" height="20" rx="5" fill="#95a5a6" />
                <line x1="35" y1="40" x2="35" y2="55" stroke="#3498db" stroke-width="3" stroke-dasharray="5,3" />
                <line x1="50" y1="40" x2="50" y2="60" stroke="#3498db" stroke-width="3" stroke-dasharray="5,3" />
                <line x1="65" y1="40" x2="65" y2="55" stroke="#3498db" stroke-width="3" stroke-dasharray="5,3" />
            </svg>
        </div>
        <div id="btn-color" class="control-btn" onclick="toggleColor()" title="Trocar Cor">
            <svg viewBox="0 0 24 24" width="35" height="35"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" fill="#333" /></svg>
        </div>
    </div>

    <div id="poop-btn" onclick="doPoop()">
        <span style="font-size: 60px;">üí©</span>
    </div>

    <div id="game-container">
        <div id="ui-layer">
            <div id="instruction-bubble">Clique em JOGAR!</div>
        </div>

        <div id="monster-container" class="monster-idle">
            <div id="mouth-sensor"></div>
            
            <div id="belly-container">
                <div id="eaten-fruits-visuals"></div>
                <div id="belly-counter"></div>
            </div>
            
            <svg id="monster-svg" viewBox="0 0 300 350" preserveAspectRatio="xMidYMid meet">
                <path id="monster-body" d="M50 300 Q20 350 80 340 L220 340 Q280 350 250 300 Q280 200 250 100 Q230 20 150 20 Q70 20 50 100 Q20 200 50 300" fill="#7bed9f" stroke="#2ecc71" stroke-width="5"/>
                <g id="dirt-group"></g>
                <circle cx="150" cy="250" r="60" fill="rgba(255,255,255,0.4)" stroke="#fff" stroke-width="3" />
                <g id="blush-group">
                    <circle cx="90" cy="180" r="15" fill="#ff7675" />
                    <circle cx="210" cy="180" r="15" fill="#ff7675" />
                </g>
                <g id="eyes">
                    <g class="blink-anim">
                        <circle cx="100" cy="100" r="25" fill="white" stroke="#333" stroke-width="2"/>
                        <circle class="eye-pupil" cx="100" cy="100" r="10" fill="black" />
                        <path class="eye-lid" d="" />
                    </g>
                    <g class="blink-anim" style="animation-delay: 0.15s;">
                        <circle cx="200" cy="100" r="25" fill="white" stroke="#333" stroke-width="2"/>
                        <circle class="eye-pupil" cx="200" cy="100" r="10" fill="black" />
                        <path class="eye-lid" d="" />
                    </g>
                </g>
                <g id="mouth-group">
                    <path class="mouth-path" d="M75 130 Q150 130 225 130 Q225 180 150 180 Q75 180 75 130 Z" fill="#333" />
                    <path class="teeth" d="M85 130 L95 145 L105 130 M195 130 L205 145 L215 130" stroke="white" stroke-width="3" fill="white"/>
                </g>
                <path id="monster-arms-left" class="arm-left" d="M60 200 Q20 220 30 180" stroke="#2ecc71" stroke-width="15" stroke-linecap="round" fill="none"/>
                <path id="monster-arms-right" class="arm-right" d="M240 200 Q280 220 270 180" stroke="#2ecc71" stroke-width="15" stroke-linecap="round" fill="none"/>
            </svg>
        </div>

        <div id="blender-wrapper">
            <div id="blender-container">
                <div id="blender-items-visuals"></div>
                <div id="blender-sensor"></div> 
                <svg viewBox="0 0 140 200" style="position:relative; z-index: 1;">
                    <path d="M20 40 L30 160 Q35 180 70 180 Q105 180 110 160 L120 40 Z" fill="rgba(200, 230, 255, 0.7)" stroke="#3498db" stroke-width="3"/>
                    <rect x="15" y="30" width="110" height="15" rx="5" fill="#333"/>
                    <rect x="25" y="180" width="90" height="20" fill="#e74c3c"/>
                    <path id="blender-liquid" d="M25 160 Q35 175 70 175 Q105 175 115 160 L118 100 Q70 110 22 100 Z" fill="#e67e22" opacity="0" style="transition: opacity 1s ease;"/>
                </svg>
            </div>
        </div>

        <div id="fruit-shelf">
            <div class="shelf-support support-left"></div>
            <div class="shelf-support support-right"></div>
        </div>
    </div>

    <script>
        // --- DADOS DAS FRUTAS (COM G√äNERO PARA GRAM√ÅTICA CORRETA) ---
        const fruitsData = {
            'morango': { color: '#e74c3c', gender: 'm', shape: '<path d="M35 10 Q55 10 60 25 Q65 60 35 70 Q5 60 10 25 Q15 10 35 10 Z" fill="#e74c3c"/><path d="M35 10 L35 2" stroke="green" stroke-width="3"/>' },
            'banana': { color: '#f1c40f', gender: 'f', shape: '<path d="M10 50 Q35 70 60 20 Q40 60 10 40 Z" fill="#f1c40f" stroke="#f39c12"/>' },
            'ma√ß√£': { color: '#c0392b', gender: 'f', shape: '<circle cx="35" cy="40" r="25" fill="#c0392b"/><path d="M35 15 Q45 5 45 15" stroke="green" stroke-width="3" fill="none"/>' },
            'uva': { color: '#8e44ad', gender: 'f', shape: '<g transform="translate(5,5)"><circle cx="30" cy="45" r="10" fill="#8e44ad"/><circle cx="20" cy="30" r="10" fill="#8e44ad"/><circle cx="40" cy="30" r="10" fill="#8e44ad"/><circle cx="30" cy="15" r="10" fill="#8e44ad"/></g>' },
            'laranja': { color: '#e67e22', gender: 'f', shape: '<circle cx="35" cy="35" r="30" fill="#e67e22"/><circle cx="35" cy="35" r="2" fill="#d35400"/>' },
            'pera': { color: '#badc58', gender: 'f', shape: '<path d="M35 5 Q55 10 55 45 Q55 65 35 65 Q15 65 15 45 Q15 10 35 5 Z" fill="#badc58"/><path d="M35 5 L35 0" stroke="#5d4037" stroke-width="3"/>' },
            'melancia': { color: '#2ecc71', gender: 'f', shape: '<path d="M5 20 Q35 65 65 20" fill="#ff6b6b" stroke="#2ecc71" stroke-width="4"/><circle cx="35" cy="35" r="2" fill="black"/>' },
            'abacaxi': { color: '#f9ca24', gender: 'm', shape: '<ellipse cx="35" cy="45" rx="20" ry="25" fill="#f9ca24"/><path d="M35 20 L35 0" stroke="green" stroke-width="4"/>' },
            'lim√£o': { color: '#6ab04c', gender: 'm', shape: '<ellipse cx="35" cy="35" rx="25" ry="20" fill="#badc58"/>' }
        };

        const monsterColors = [
            { fill: '#7bed9f', stroke: '#2ecc71' }, { fill: '#ff7675', stroke: '#d63031' },
            { fill: '#74b9ff', stroke: '#0984e3' }, { fill: '#a29bfe', stroke: '#6c5ce7' }, { fill: '#ffeaa7', stroke: '#fdcb6e' } 
        ];
        let colorIndex = 0;

        let state = {
            mode: 'normal', targetCount: 0, eatenCount: 0, targetType: '',
            blenderRecipe: {}, blenderReady: false, 
            poopMeter: 0, isPlaying: false, needsPoop: false, activeDrag: null,
            justActivatedBlender: false, lastSoundTime: 0, lastAmbientSpeechTime: 0,
            dirtSpots: [], lastCleanTime: 0,
            audioQueue: [] 
        };

        const MAX_POOP = 6;
        const els = {
            instruction: document.getElementById('instruction-bubble'),
            monster: document.getElementById('monster-container'),
            monsterBody: document.getElementById('monster-body'),
            bellyCounter: document.getElementById('belly-counter'),
            eatenFruits: document.getElementById('eaten-fruits-visuals'),
            blenderWrapper: document.getElementById('blender-wrapper'),
            blenderContainer: document.getElementById('blender-container'),
            blenderLiquid: document.getElementById('blender-liquid'),
            blenderSensor: document.getElementById('blender-sensor'),
            blenderItems: document.getElementById('blender-items-visuals'),
            mouthSensor: document.getElementById('mouth-sensor'),
            poopBtn: document.getElementById('poop-btn'),
            gameContainer: document.getElementById('game-container'),
            btnBlender: document.getElementById('btn-blender'),
            btnHeart: document.getElementById('btn-heart'),
            btnBath: document.getElementById('btn-bath'),
            shelf: document.getElementById('fruit-shelf'),
            sponge: document.getElementById('sponge-cursor'),
            dirtGroup: document.getElementById('dirt-group')
        };

        // --- SISTEMA DE √ÅUDIO OTIMIZADO (WEB AUDIO API) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioBufferCache = {}; 

        // Carrega um audio para memoria
        async function loadAudioBuffer(name) {
            if (audioBufferCache[name]) return audioBufferCache[name];
            try {
                const response = await fetch(`mp3/${name}.mp3`);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                audioBufferCache[name] = audioBuffer;
                return audioBuffer;
            } catch (e) {
                console.error("Erro ao carregar audio:", name, e);
                return null;
            }
        }

        // --- FUN√á√ÉO DE CORTE DE SIL√äNCIO ---
        function getTrimmedDetails(buffer) {
            const data = buffer.getChannelData(0); 
            const len = data.length;
            const threshold = 0.015; 

            let start = 0;
            let end = len - 1;

            while (start < len && Math.abs(data[start]) < threshold) start++;
            while (end > start && Math.abs(data[end]) < threshold) end--;
            
            if (end <= start) return { offset: 0, duration: buffer.duration };

            const trimStart = start / buffer.sampleRate;
            const trimEnd = end / buffer.sampleRate;
            const trimDuration = trimEnd - trimStart;

            return { offset: trimStart, duration: trimDuration };
        }

        // Toca lista de audios em sequencia
        async function playAudioSequence(list) {
            if (!list || list.length === 0) return;
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            
            const promises = list.map(name => loadAudioBuffer(name));
            const buffers = await Promise.all(promises);
            
            let nextStartTime = audioCtx.currentTime + 0.02; 
            
            buffers.forEach(buffer => {
                if (buffer) {
                    const source = audioCtx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioCtx.destination);
                    
                    const trim = getTrimmedDetails(buffer);
                    source.start(nextStartTime, trim.offset, trim.duration);
                    
                    // Ajuste FINO: -0.01s (quase nada de overlap, apenas colado)
                    nextStartTime += (trim.duration - 0.01); 
                }
            });
        }

        function playVoice(input, isAmbient = false) {
            if (isAmbient && (Date.now() - state.lastAmbientSpeechTime < 2000)) return;
            if (isAmbient) state.lastAmbientSpeechTime = Date.now();

            if (Array.isArray(input)) {
                playAudioSequence(input);
            } else {
                playAudioSequence([input]);
            }
        }

        // Sintetizador de efeitos sonoros
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const now = audioCtx.currentTime;
            if (type === 'water' && now - state.lastSoundTime < 0.15) return;
            state.lastSoundTime = now;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode); gainNode.connect(audioCtx.destination);

            if (type === 'eat') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(); osc.stop(now + 0.15);
            } else if (type === 'fart') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                gainNode.gain.setValueAtTime(0.4, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(); osc.stop(now + 0.5);
            } else if (type === 'heart') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(523.25, now);
                osc.frequency.exponentialRampToValueAtTime(783.99, now + 0.2);
                gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(); osc.stop(now + 0.3);
            } else if (type === 'water') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400 + Math.random() * 200, now);
                osc.frequency.linearRampToValueAtTime(800 + Math.random() * 200, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(); osc.stop(now + 0.1);
            } else {
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(); osc.stop(now + 0.1);
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            if (audioCtx.state === 'suspended') audioCtx.resume();
            setupBlenderDrag();
            setupInteractionEvents();
            startRound();
            scheduleNextDirt();
        }

        function scheduleNextDirt() {
            const delay = 30000 + Math.random() * 20000;
            setTimeout(() => {
                tryAddDirt();
                scheduleNextDirt(); 
            }, delay);
        }

        function tryAddDirt() {
            if (state.dirtSpots.length > 8) return;
            let attempts = 0;
            let success = false;
            let x, y, r;

            while (!success && attempts < 10) {
                x = 60 + Math.random() * 180;
                y = 100 + Math.random() * 200;
                r = 15 + Math.random() * 15; 
                if (y < 160) { attempts++; continue; }
                let overlap = false;
                for (let spot of state.dirtSpots) {
                    const dx = spot.x - x;
                    const dy = spot.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < (spot.r + r + 5)) { overlap = true; break; }
                }
                if (!overlap) success = true;
                attempts++;
            }
            if (success) addDirtSpot(x, y, r);
        }

        function addDirtSpot(x, y, r) {
            const spot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            spot.setAttribute("cx", x);
            spot.setAttribute("cy", y);
            spot.setAttribute("r", r);
            spot.setAttribute("class", "dirt-spot");
            els.dirtGroup.appendChild(spot);
            state.dirtSpots.push({ x, y, r, el: spot });
        }

        function removeDirtSpot(spotData) {
            const index = state.dirtSpots.indexOf(spotData);
            if (index > -1) {
                spotData.el.style.opacity = '0';
                spotData.el.style.transform = 'scale(1.5)';
                setTimeout(() => {
                    if (spotData.el.parentNode) spotData.el.parentNode.removeChild(spotData.el);
                }, 500);
                state.dirtSpots.splice(index, 1);
                createParticle(spotData.x, spotData.y, 'bubble');
                playSound('water');
            }
        }

        function toggleColor() {
            if (state.needsPoop) return;
            colorIndex = (colorIndex + 1) % monsterColors.length;
            const theme = monsterColors[colorIndex];
            els.monsterBody.setAttribute('fill', theme.fill);
            els.monsterBody.setAttribute('stroke', theme.stroke);
            document.getElementById('monster-arms-left').setAttribute('stroke', theme.stroke);
            document.getElementById('monster-arms-right').setAttribute('stroke', theme.stroke);
            playSound('pop');
        }

        function checkPoopStatus() {
            if (state.poopMeter >= MAX_POOP) {
                state.needsPoop = true;
                els.monster.className = 'sick-face';
                els.instruction.innerHTML = "Ai minha barriga!";
                playVoice('dor_barriga'); 
                els.poopBtn.style.display = 'flex';
                els.shelf.style.opacity = '0.3';
                els.shelf.style.pointerEvents = 'none';
                return true;
            }
            return false;
        }

        function doPoop() {
            playSound('fart');
            const poopVisual = document.createElement('div');
            poopVisual.innerHTML = 'üí©';
            poopVisual.className = 'poop-drop';
            const mRect = els.monster.getBoundingClientRect();
            poopVisual.style.left = (mRect.left + mRect.width/2) + 'px'; 
            poopVisual.style.top = (mRect.bottom - 40) + 'px'; 
            els.gameContainer.appendChild(poopVisual);
            setTimeout(() => poopVisual.remove(), 2500);

            state.poopMeter = 0; state.needsPoop = false;
            els.poopBtn.style.display = 'none';
            els.monster.className = 'monster-idle';
            els.shelf.style.opacity = '1';
            els.shelf.style.pointerEvents = 'auto';
            playVoice('alivio'); 
            els.bellyCounter.innerText = '';
            els.eatenFruits.innerHTML = '';
            setTimeout(startRound, 2500);
        }

        function clearModeVisuals() {
            els.btnHeart.classList.remove('btn-active');
            els.btnBlender.classList.remove('btn-active');
            els.btnBath.classList.remove('btn-active');
            els.monster.classList.remove('heart-face');
            els.monster.classList.remove('interactive');
            els.blenderWrapper.style.display = 'none';
            resetBlender();
            els.sponge.style.display = 'none';
            els.shelf.style.opacity = '1';
            els.shelf.style.pointerEvents = 'auto';
        }

        function setMode(newMode) {
            if (state.needsPoop) return;

            if (state.mode === newMode) {
                state.mode = 'normal';
                clearModeVisuals();
                startRound();
                return;
            }

            clearModeVisuals();
            state.mode = newMode;

            if (state.mode === 'blender') {
                els.blenderWrapper.style.display = 'block';
                els.btnBlender.classList.add('btn-active');
                state.justActivatedBlender = true;
                startRound();
            } 
            else if (state.mode === 'heart') {
                els.btnHeart.classList.add('btn-active');
                els.monster.classList.add('heart-face');
                els.monster.classList.add('interactive'); 
                els.instruction.innerHTML = "D√™ carinho no monstro!";
                
                playVoice('quero_carinho'); 
                if(Math.random() > 0.5) setTimeout(()=> playVoice('instrucao_carinho'), 2000);

                hideShelf();
            } 
            else if (state.mode === 'bath') {
                els.btnBath.classList.add('btn-active');
                els.monster.classList.add('interactive'); 
                els.instruction.innerHTML = "Hora do banho!";
                
                playVoice('modo_banho'); 
                if(Math.random() > 0.5) setTimeout(()=> playVoice('instrucao_banho'), 2000);

                els.sponge.style.display = 'block';
                hideShelf();
            } 
            else {
                startRound();
            }
        }

        function hideShelf() {
            els.shelf.style.opacity = '0.3';
            els.shelf.style.pointerEvents = 'none';
            const oldFruits = els.shelf.querySelectorAll('.basket-item');
            oldFruits.forEach(el => el.remove());
        }

        function setupInteractionEvents() {
            const container = document.getElementById('game-container');
            const bathSounds = ["banho_1", "banho_2", "banho_3", "banho_4", "banho_5", "banho_6"];
            const heartSounds = ["carinho_1", "carinho_2", "carinho_3", "carinho_4"];

            const handleTap = (e) => {
                if (state.mode !== 'heart') return;
                if(e.type === 'touchstart') e.preventDefault(); 

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const mRect = els.monster.getBoundingClientRect();
                if (clientX >= mRect.left && clientX <= mRect.right && 
                    clientY >= mRect.top && clientY <= mRect.bottom) {
                    
                    createParticle(clientX, clientY, 'heart');
                    playSound('heart');
                    if(Math.random() > 0.7) {
                        playVoice(heartSounds[Math.floor(Math.random()*heartSounds.length)], true);
                    }
                }
            };

            const handleMove = (e) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                if (state.mode === 'bath') {
                    els.sponge.style.left = (clientX - 30) + 'px';
                    els.sponge.style.top = (clientY - 30) + 'px';

                    const isTouching = (e.type === 'touchmove') || (e.buttons === 1);
                    if (!isTouching) return;

                    const mRect = els.monster.getBoundingClientRect();
                    const isOverMonster = clientX >= mRect.left && clientX <= mRect.right && 
                                          clientY >= mRect.top && clientY <= mRect.bottom;

                    if (isOverMonster) {
                        const now = Date.now();
                        if (state.dirtSpots.length > 0 && now - state.lastCleanTime > 800) {
                            const randomSpotIndex = Math.floor(Math.random() * state.dirtSpots.length);
                            removeDirtSpot(state.dirtSpots[randomSpotIndex]);
                            state.lastCleanTime = now;
                        }

                        if (Math.random() > 0.8) {
                            createParticle(clientX, clientY, 'bubble');
                            playSound('water');
                        }
                        
                        if (Math.random() > 0.98) {
                            playVoice(bathSounds[Math.floor(Math.random() * bathSounds.length)], true);
                        }
                    }
                }
            };

            els.monster.addEventListener('mousedown', handleTap);
            els.monster.addEventListener('touchstart', handleTap, {passive: false});

            container.addEventListener('mousemove', handleMove);
            container.addEventListener('touchmove', handleMove, {passive: false});
        }

        function createParticle(x, y, type) {
            const p = document.createElement('div');
            p.className = type === 'heart' ? 'heart-particle' : 'bubble-particle';
            
            if (type === 'heart') {
                p.innerHTML = ['‚ù§Ô∏è','üíñ','‚ú®','üíï'][Math.floor(Math.random()*4)];
            }
            
            const randX = (Math.random() - 0.5) * 40;
            p.style.left = (x + randX) + 'px';
            p.style.top = y + 'px';
            
            els.gameContainer.appendChild(p);
            setTimeout(() => p.remove(), 2000);
        }

        function startRound() {
            if (checkPoopStatus()) return;
            state.isPlaying = true;
            state.blenderReady = false;
            els.blenderContainer.classList.remove('blender-ready');
            els.blenderItems.innerHTML = '';
            
            const oldFruits = els.shelf.querySelectorAll('.basket-item');
            oldFruits.forEach(el => el.remove());

            if (state.mode === 'normal') setupNormalRound();
            else if (state.mode === 'blender') setupBlenderRound();
        }

        function fillBasket(requiredTypes) {
            let options = [...requiredTypes];
            const allTypes = Object.keys(fruitsData);
            while(options.length < 4) { 
                const randomType = allTypes[Math.floor(Math.random() * allTypes.length)];
                if(!options.includes(randomType)) options.push(randomType);
            }
            options.sort(() => Math.random() - 0.5);
            options.forEach(type => {
                const item = document.createElement('div');
                item.className = 'basket-item';
                item.innerHTML = `<svg viewBox="0 0 70 70" style="width:100%; height:100%; pointer-events:none;">${fruitsData[type].shape}</svg>`;
                item.dataset.type = type;
                item.addEventListener('touchstart', handleFruitDragStart, {passive: false});
                item.addEventListener('mousedown', handleFruitDragStart);
                els.shelf.appendChild(item);
            });
        }

        function handleFruitDragStart(e) {
            if (!state.isPlaying || state.needsPoop) return;
            e.preventDefault();
            const type = e.currentTarget.dataset.type;
            const touch = e.type === 'touchstart' ? e.touches[0] : e;

            const dragEl = document.createElement('div');
            dragEl.className = 'fruit-drag';
            dragEl.dataset.type = type;
            dragEl.innerHTML = `<svg viewBox="0 0 70 70">${fruitsData[type].shape}</svg>`;
            dragEl.style.left = (touch.clientX - 45) + 'px';
            dragEl.style.top = (touch.clientY - 45) + 'px';
            els.gameContainer.appendChild(dragEl);
            state.activeDrag = dragEl;
            els.monster.classList.add('mouth-open');

            const moveHandler = (me) => {
                const mt = me.type === 'touchmove' ? me.touches[0] : me;
                state.activeDrag.style.left = (mt.clientX - 45) + 'px';
                state.activeDrag.style.top = (mt.clientY - 45) + 'px';
            };
            const endHandler = () => {
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endHandler);
                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endHandler);
                els.monster.classList.remove('mouth-open');
                if (state.activeDrag) { checkDrop(state.activeDrag); state.activeDrag = null; }
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endHandler);
            document.addEventListener('touchmove', moveHandler, {passive: false});
            document.addEventListener('touchend', endHandler);
        }

        function checkDrop(el) {
            const rect = el.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            let dropped = false;

            if (state.mode === 'normal') {
                const mouth = els.mouthSensor.getBoundingClientRect();
                if (cx >= mouth.left && cx <= mouth.right && cy >= mouth.top && cy <= mouth.bottom) {
                    if (el.dataset.type === state.targetType) { eatFruitNormal(el); dropped = true; }
                    else { playVoice('erro'); playSound('pop'); }
                }
            } else if (state.mode === 'blender') {
                const blenderRect = els.blenderSensor.getBoundingClientRect();
                if (cx >= blenderRect.left && cx <= blenderRect.right && cy >= blenderRect.top && cy <= blenderRect.bottom) {
                    checkBlenderIngredient(el); dropped = true;
                }
            }
            if (!dropped) {
                el.style.transition = '0.3s'; el.style.transform = 'scale(0)';
                setTimeout(() => el.remove(), 300);
            }
        }

        // --- FUN√á√ÉO AUXILIAR PARA GERAR NOME NO PLURAL CORRETO ---
        function getFruitName(rawType, count) {
            // Remove acentos e caracteres especiais para nome de arquivo
            let safeName = rawType.replace(/[√£√°√†√¢]/g, "a").replace("√ß", "c").replace("√™", "e").replace("√µ", "o");
            
            // Se for plural (mais de 1), adiciona "s" ou trata irregularidades
            if (count > 1) {
                if (safeName === 'limao') return 'limoes'; // Irregular
                // Para os demais, apenas adiciona 's' (maca -> macas, morango -> morangos)
                return safeName + 's'; 
            }
            
            // Singular
            return safeName;
        }

        function setupNormalRound() {
            const types = Object.keys(fruitsData);
            state.targetType = types[Math.floor(Math.random() * types.length)];
            state.targetCount = Math.floor(Math.random() * 3) + 1; // 1 a 3
            state.eatenCount = 0;
            els.bellyCounter.innerText = '';
            els.eatenFruits.innerHTML = '';
            
            // L√≥gica de Plural do Texto (para exibi√ß√£o na tela)
            let pluralText = state.targetType;
            if (state.targetCount > 1) {
                if (state.targetType === 'lim√£o') pluralText = 'lim√µes';
                else if (state.targetType === 'melancia') pluralText = 'melancias';
                else if (state.targetType === 'abacaxi') pluralText = 'abacaxis';
                else pluralText = state.targetType + 's';
            }

            els.instruction.innerHTML = `Quero <span class="highlight-num">${state.targetCount}</span> ${pluralText}!`;
            
            // L√≥gica de G√™nero do √Åudio (Um/Uma/Dois/Duas)
            const gender = fruitsData[state.targetType].gender;
            let numAudio = state.targetCount.toString(); // Default 3 (tres)
            
            if (state.targetCount === 1) numAudio = (gender === 'm') ? 'um' : 'uma';
            if (state.targetCount === 2) numAudio = (gender === 'm') ? 'dois' : 'duas';
            if (state.targetCount === 3) numAudio = 'tres'; // Garanta que tem "tres.mp3"

            // Define nome do arquivo de √°udio (singular ou plural)
            const audioFruitName = getFruitName(state.targetType, state.targetCount);
            
            // TOCA: "Quero" -> NumAudio -> Fruta(plural se >1)
            playVoice(['quero', numAudio, audioFruitName]);

            fillBasket([state.targetType]);
        }

        function eatFruitNormal(el) {
            const bellyClone = el.cloneNode(true);
            bellyClone.className = 'eaten-fruit';
            els.eatenFruits.appendChild(bellyClone);
            el.remove();
            playSound('eat');
            state.targetCount--; state.eatenCount++;
            els.bellyCounter.innerText = state.eatenCount;
            
            // Fala apenas o numeral ao comer (1, 2, 3)
            playVoice(state.eatenCount.toString()); 
            
            if (state.targetCount <= 0) {
                setTimeout(() => playVoice('delicia'), 1000);
                state.poopMeter++; state.isPlaying = false; setTimeout(startRound, 2500);
            }
        }

        function setupBlenderRound() {
            const types = Object.keys(fruitsData);
            const t1 = types[Math.floor(Math.random()*types.length)];
            let t2 = types[Math.floor(Math.random()*types.length)];
            while(t1===t2) t2 = types[Math.floor(Math.random()*types.length)];
            state.blenderRecipe = { [t1]: 1, [t2]: 1 };
            els.blenderLiquid.style.opacity = 0;
            els.instruction.innerHTML = `Vitamina: <span class="highlight-num">1 ${t1}</span> e <span class="highlight-num">1 ${t2}</span>`;
            
            // Nomes seguros para arquivo
            const f1Safe = getFruitName(t1, 1);
            const f2Safe = getFruitName(t2, 1);
            
            // Identifica g√™nero para falar "Um" ou "Uma"
            const g1 = fruitsData[t1].gender;
            const num1 = (g1 === 'm') ? 'um' : 'uma';
            
            const g2 = fruitsData[t2].gender;
            const num2 = (g2 === 'm') ? 'um' : 'uma';

            if (state.justActivatedBlender) {
                state.justActivatedBlender = false;
                // "Vamos fazer uma vitamina" + "Vitamina de" + UM/UMA + Fruta1 + "com" + UM/UMA + Fruta2
                playVoice(['modo_vitamina', 'vitamina_de', num1, f1Safe, 'com', num2, f2Safe]);
            } else {
                playVoice(['vitamina_de', num1, f1Safe, 'com', num2, f2Safe]);
            }
            
            fillBasket([t1, t2]);
        }

        function checkBlenderIngredient(el) {
            const type = el.dataset.type;
            if (state.blenderRecipe[type] > 0) {
                state.blenderRecipe[type]--;
                const tinyFruit = document.createElement('div');
                tinyFruit.className = 'blender-fruit-tiny';
                tinyFruit.innerHTML = `<svg viewBox="0 0 70 70">${fruitsData[type].shape}</svg>`;
                els.blenderItems.appendChild(tinyFruit);
                el.remove(); playSound('pop');
                
                const remaining = [];
                for (let [t, q] of Object.entries(state.blenderRecipe)) { if (q > 0) remaining.push(t); }
                
                if (remaining.length > 0) {
                    // Toca "Falta" + Um/Uma + Fruta (singular)
                    const gender = fruitsData[remaining[0]].gender;
                    const numAudio = (gender === 'm') ? 'um' : 'uma';
                    const fSafe = getFruitName(remaining[0], 1); // Singular
                    
                    playVoice(['falta', numAudio, fSafe]);
                }

                if (Object.values(state.blenderRecipe).every(v => v === 0)) finishBlender();
            } else { 
                playVoice('erro'); 
                el.style.transition = '0.3s'; el.style.transform = 'scale(0)';
                setTimeout(() => el.remove(), 300);
            }
        }

        function finishBlender() {
            els.instruction.innerHTML = "Misturando...";
            playVoice('misturando');
            els.blenderContainer.classList.add('blender-ready');
            setTimeout(() => {
                els.blenderItems.innerHTML = '';
                els.blenderLiquid.style.opacity = 1; 
                state.blenderReady = true;
                els.instruction.innerHTML = "D√™ para o monstro!";
                playVoice('da_pra_mim');
            }, 1500);
        }

        function setupBlenderDrag() {
            let startX, startY;
            const wrapper = els.blenderWrapper; 
            function onStart(e) {
                if (!state.blenderReady) return;
                e.preventDefault(); 
                const touch = e.type === 'touchstart' ? e.touches[0] : e;
                startX = touch.clientX; startY = touch.clientY;
                wrapper.style.zIndex = 1000;
                function onMove(me) {
                    const mt = me.type === 'touchmove' ? me.touches[0] : me;
                    wrapper.style.transform = `translate(${mt.clientX - startX}px, ${mt.clientY - startY}px)`;
                    const mRect = els.mouthSensor.getBoundingClientRect();
                    const bRect = wrapper.getBoundingClientRect();
                    if (bRect.left < mRect.right && bRect.right > mRect.left && bRect.top < mRect.bottom) els.monster.classList.add('mouth-open');
                    else els.monster.classList.remove('mouth-open');
                }
                function onEnd() {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    const mRect = els.mouthSensor.getBoundingClientRect();
                    const bRect = wrapper.getBoundingClientRect();
                    if (bRect.left < mRect.right && bRect.right > mRect.left && bRect.top < mRect.bottom) feedMonsterJuice();
                    else { wrapper.style.transition = '0.3s'; wrapper.style.transform = 'none'; setTimeout(()=>wrapper.style.transition='', 300); }
                }
                document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchmove', onMove, {passive:false}); document.addEventListener('touchend', onEnd);
            }
            els.blenderSensor.addEventListener('mousedown', onStart);
            els.blenderSensor.addEventListener('touchstart', onStart, {passive:false});
        }

        function feedMonsterJuice() {
            state.blenderReady = false;
            els.blenderContainer.classList.remove('blender-ready');
            const mRect = els.mouthSensor.getBoundingClientRect();
            const bRect = els.blenderWrapper.getBoundingClientRect();
            const moveX = (mRect.left + mRect.width/2 - (bRect.left + bRect.width/2)) - 20;
            const moveY = (mRect.top + mRect.height/2 - (bRect.top + bRect.height/2)) - 40;
            els.blenderWrapper.style.transition = 'transform 1s ease-in-out';
            els.blenderWrapper.style.transform = `translate(${moveX}px, ${moveY}px) rotate(-100deg)`;
            setTimeout(() => {
                els.blenderLiquid.style.opacity = 0;
                playSound('eat'); 
                
                playVoice('obrigado_vitamina');
                
                setTimeout(() => {
                    els.blenderWrapper.style.transition = 'transform 0.5s ease';
                    els.blenderWrapper.style.transform = 'none';
                    state.poopMeter += 2; 
                    setTimeout(startRound, 3500);
                }, 1000);
            }, 1000);
        }

        function resetBlender() {
            els.blenderWrapper.style.transform = 'none';
            els.blenderContainer.classList.remove('blender-ready');
            els.blenderLiquid.style.opacity = 0;
            els.blenderItems.innerHTML = '';
        }
    </script>
</body>
</html>
